import {
  initialStores,
  initialOutlets,
  pendingApprovals,
  creditDues,
  stockAlerts,
  recentActivities
} from './dummyData';

// Add initial managers data
export const initialManagers = [
  {
    id: 1,
    name: 'John Smith',
    email: 'john.smith@example.com',
    phone: '+1 (555) 123-4567',
    storeId: 1,
    storeName: 'Downtown Store',
    status: 'Active',
    lastLogin: '2024-01-16 09:30 AM',
    invoices: 145,
    password: 'autogenerated123',
    credentialMethod: 'auto-generate',
    deliveryMethod: 'email',
    createdAt: '2024-01-01'
  },
  {
    id: 2,
    name: 'Sarah Johnson',
    email: 'sarahj@example.com',
    phone: '+1 (555) 234-5678',
    storeId: 2,
    storeName: 'Westside Outlet',
    status: 'Active',
    lastLogin: '2024-01-16 08:15 AM',
    invoices: 98,
    password: 'autogenerated456',
    credentialMethod: 'invite-link',
    deliveryMethod: 'email',
    createdAt: '2024-01-05'
  },
  {
    id: 3,
    name: 'Mike Davis',
    email: 'mike.davis@example.com',
    phone: '+1 (555) 345-6789',
    storeId: 3,
    storeName: 'Central Plaza',
    status: 'Not Logged In',
    lastLogin: 'Never',
    invoices: 0,
    password: 'pending',
    credentialMethod: 'invite-link',
    deliveryMethod: 'email',
    createdAt: '2024-01-10'
  }
];

// Add initial products data
export const initialProducts = [
  {
    id: 1,
    name: 'Premium Coffee Beans',
    sku: 'PCB-001',
    category: 'Beverages',
    price: 24.99,
    stock: 450,
    minStock: 100,
    status: 'In Stock',
    createdAt: '2024-01-01',
    description: 'Premium quality coffee beans'
  },
  {
    id: 2,
    name: 'Organic Tea Leaves',
    sku: 'OTL-002',
    category: 'Beverages',
    price: 18.50,
    stock: 320,
    minStock: 150,
    status: 'In Stock',
    createdAt: '2024-01-02',
    description: 'Organic tea leaves from Assam'
  },
  {
    id: 3,
    name: 'Chocolate Bars',
    sku: 'CHB-003',
    category: 'Snacks',
    price: 3.99,
    stock: 850,
    minStock: 200,
    status: 'In Stock',
    createdAt: '2024-01-03',
    description: 'Delicious milk chocolate bars'
  },
  {
    id: 4,
    name: 'Energy Drinks',
    sku: 'END-004',
    category: 'Beverages',
    price: 2.50,
    stock: 125,
    minStock: 100,
    status: 'In Stock',
    createdAt: '2024-01-04',
    description: 'High energy drinks'
  },
  {
    id: 5,
    name: 'Frozen Pizza',
    sku: 'FPZ-005',
    category: 'Frozen',
    price: 8.99,
    stock: 280,
    minStock: 150,
    status: 'In Stock',
    createdAt: '2024-01-05',
    description: 'Frozen pepperoni pizza'
  }
];

// Add categories data
export const initialCategories = [
  'Beverages',
  'Snacks',
  'Frozen',
  'Dairy',
  'Bakery',
  'Meat',
  'Produce',
  'Canned Goods',
  'Cleaning Supplies',
  'Personal Care'
];

// Add initial stock distributions data
export const initialDistributions = [
  {
    id: 'DIST-001',
    storeId: 1,
    storeName: 'Downtown Store',
    managerId: 1,
    managerName: 'John Smith',
    date: '2024-01-15',
    products: [
      { productId: 1, productName: 'Premium Coffee Beans', quantity: 5, price: 24.99, total: 124.95 },
      { productId: 2, productName: 'Organic Tea Leaves', quantity: 8, price: 18.50, total: 148.00 }
    ],
    totalItems: 12,
    totalValue: 2450.00,
    paymentType: 'Paid',
    status: 'Completed',
    notes: 'Regular restocking',
    createdAt: '2024-01-15T10:30:00Z',
    discount: 0
  },
  {
    id: 'DIST-002',
    storeId: 2,
    storeName: 'Westside Outlet',
    managerId: 2,
    managerName: 'Sarah Johnson',
    date: '2024-01-14',
    products: [
      { productId: 3, productName: 'Chocolate Bars', quantity: 15, price: 3.99, total: 59.85 },
      { productId: 5, productName: 'Frozen Pizza', quantity: 12, price: 8.99, total: 107.88 }
    ],
    totalItems: 8,
    totalValue: 1820.50,
    paymentType: 'Credit',
    status: 'Completed',
    notes: 'New store setup',
    createdAt: '2024-01-14T14:20:00Z',
    discount: 0
  },
  {
    id: 'DIST-003',
    storeId: 3,
    storeName: 'Central Plaza',
    managerId: 3,
    managerName: 'Mike Davis',
    date: '2024-01-14',
    products: [
      { productId: 1, productName: 'Premium Coffee Beans', quantity: 10, price: 24.99, total: 249.90 },
      { productId: 4, productName: 'Energy Drinks', quantity: 20, price: 2.50, total: 50.00 }
    ],
    totalItems: 15,
    totalValue: 3200.00,
    paymentType: 'Paid',
    status: 'In Transit',
    notes: 'Urgent delivery',
    createdAt: '2024-01-14T09:15:00Z',
    discount: 5
  },
  {
    id: 'DIST-004',
    storeId: 4,
    storeName: 'North Branch',
    managerId: null,
    managerName: 'Emily Davis',
    date: '2024-01-13',
    products: [
      { productId: 2, productName: 'Organic Tea Leaves', quantity: 6, price: 18.50, total: 111.00 },
      { productId: 3, productName: 'Chocolate Bars', quantity: 25, price: 3.99, total: 99.75 }
    ],
    totalItems: 10,
    totalValue: 1950.75,
    paymentType: 'Credit',
    status: 'Pending',
    notes: 'Waiting for manager approval',
    createdAt: '2024-01-13T16:45:00Z',
    discount: 0
  },
  {
    id: 'DIST-005',
    storeId: 1,
    storeName: 'Downtown Store',
    managerId: 1,
    managerName: 'John Smith',
    date: '2024-01-12',
    products: [
      { productId: 5, productName: 'Frozen Pizza', quantity: 18, price: 8.99, total: 161.82 },
      { productId: 4, productName: 'Energy Drinks', quantity: 15, price: 2.50, total: 37.50 }
    ],
    totalItems: 20,
    totalValue: 4100.00,
    paymentType: 'Paid',
    status: 'Completed',
    notes: 'Monthly bulk order',
    createdAt: '2024-01-12T11:00:00Z',
    discount: 10
  }
];

// Add initial invoices data
export const initialInvoices = [
  {
    id: 'INV-001',
    outletName: 'Downtown Retail',
    managerName: 'John Smith',
    storeName: 'Downtown Store',
    date: '2024-01-15',
    totalItems: 8,
    totalAmount: 1250.00,
    paymentType: 'Credit',
    status: 'Pending',
    products: [
      { productName: 'Premium Coffee Beans', quantity: 3, price: 24.99, total: 74.97 },
      { productName: 'Organic Tea Leaves', quantity: 5, price: 18.50, total: 92.50 }
    ],
    notes: 'Regular monthly order',
    createdAt: '2024-01-15T14:30:00Z'
  },
  {
    id: 'INV-002',
    outletName: 'Westside Shop',
    managerName: 'Sarah Johnson',
    storeName: 'Westside Outlet',
    date: '2024-01-14',
    totalItems: 12,
    totalAmount: 2100.50,
    paymentType: 'Paid',
    status: 'Approved',
    products: [
      { productName: 'Chocolate Bars', quantity: 10, price: 3.99, total: 39.90 },
      { productName: 'Frozen Pizza', quantity: 2, price: 8.99, total: 17.98 }
    ],
    notes: 'Special promotion order',
    createdAt: '2024-01-14T11:20:00Z'
  },
  {
    id: 'INV-003',
    outletName: 'Central Market',
    managerName: 'Mike Wilson',
    storeName: 'Central Plaza',
    date: '2024-01-14',
    totalItems: 6,
    totalAmount: 890.00,
    paymentType: 'Credit',
    status: 'Rejected',
    products: [
      { productName: 'Energy Drinks', quantity: 4, price: 2.50, total: 10.00 },
      { productName: 'Chocolate Bars', quantity: 2, price: 3.99, total: 7.98 }
    ],
    notes: 'Quantity mismatch',
    createdAt: '2024-01-14T09:45:00Z'
  },
  {
    id: 'INV-004',
    outletName: 'North Branch',
    managerName: 'Emily Davis',
    storeName: 'North Branch',
    date: '2024-01-13',
    totalItems: 15,
    totalAmount: 3200.00,
    paymentType: 'Paid',
    status: 'Approved',
    products: [
      { productName: 'Frozen Pizza', quantity: 8, price: 8.99, total: 71.92 },
      { productName: 'Premium Coffee Beans', quantity: 7, price: 24.99, total: 174.93 }
    ],
    notes: 'New store setup',
    createdAt: '2024-01-13T16:15:00Z'
  },
  {
    id: 'INV-005',
    outletName: 'East Side Store',
    managerName: 'John Smith',
    storeName: 'Downtown Store',
    date: '2024-01-12',
    totalItems: 10,
    totalAmount: 1750.25,
    paymentType: 'Credit',
    status: 'Pending',
    products: [
      { productName: 'Organic Tea Leaves', quantity: 6, price: 18.50, total: 111.00 },
      { productName: 'Energy Drinks', quantity: 4, price: 2.50, total: 10.00 }
    ],
    notes: 'Urgent delivery request',
    createdAt: '2024-01-12T13:40:00Z'
  }
];

// Add initial expenditure categories
export const initialExpenseCategories = [
  'Transport',
  'Maintenance',
  'Utilities',
  'Office Supplies',
  'Marketing',
  'Salaries',
  'Rent',
  'Insurance',
  'Taxes',
  'Miscellaneous'
];

// Add initial expenditures data
export const initialExpenditures = [
  {
    id: 1,
    date: '2024-01-15',
    category: 'Transport',
    description: 'Delivery truck fuel',
    amount: 450.00,
    status: 'Approved',
    approvedBy: 'Admin',
    approvedDate: '2024-01-15T10:00:00Z',
    notes: 'Monthly fuel expense',
    createdAt: '2024-01-15T09:30:00Z'
  },
  {
    id: 2,
    date: '2024-01-14',
    category: 'Maintenance',
    description: 'Store AC repair',
    amount: 320.50,
    status: 'Approved',
    approvedBy: 'Admin',
    approvedDate: '2024-01-14T15:20:00Z',
    notes: 'Emergency repair',
    createdAt: '2024-01-14T14:00:00Z'
  },
  {
    id: 3,
    date: '2024-01-13',
    category: 'Utilities',
    description: 'Monthly electricity bill',
    amount: 890.00,
    status: 'Pending',
    approvedBy: null,
    approvedDate: null,
    notes: 'December electricity bill',
    createdAt: '2024-01-13T11:45:00Z'
  },
  {
    id: 4,
    date: '2024-01-12',
    category: 'Office Supplies',
    description: 'Stationery and printer ink',
    amount: 210.00,
    status: 'Approved',
    approvedBy: 'Admin',
    approvedDate: '2024-01-12T16:30:00Z',
    notes: 'Quarterly office supplies',
    createdAt: '2024-01-12T14:15:00Z'
  },
  {
    id: 5,
    date: '2024-01-11',
    category: 'Marketing',
    description: 'Social media advertising',
    amount: 640.00,
    status: 'Approved',
    approvedBy: 'Admin',
    approvedDate: '2024-01-11T12:10:00Z',
    notes: 'January marketing campaign',
    createdAt: '2024-01-11T10:30:00Z'
  }
];

// Add initial reports data
export const initialReports = [
  {
    id: 1,
    name: 'Monthly Inventory Report',
    type: 'Inventory',
    date: '2024-01-15',
    size: '2.4 MB',
    downloadUrl: '#',
    description: 'Complete inventory analysis for January',
    createdAt: '2024-01-15T14:00:00Z'
  },
  {
    id: 2,
    name: 'Invoice Summary December',
    type: 'Invoice',
    date: '2024-01-10',
    size: '1.8 MB',
    downloadUrl: '#',
    description: 'December invoice performance report',
    createdAt: '2024-01-10T11:30:00Z'
  },
  {
    id: 3,
    name: 'Credit Dues Report',
    type: 'Credit',
    date: '2024-01-08',
    size: '856 KB',
    downloadUrl: '#',
    description: 'Outstanding credit payments analysis',
    createdAt: '2024-01-08T09:15:00Z'
  },
  {
    id: 4,
    name: 'Expense Report Q4',
    type: 'Expense',
    date: '2024-01-05',
    size: '1.2 MB',
    downloadUrl: '#',
    description: 'Quarterly expense breakdown',
    createdAt: '2024-01-05T16:45:00Z'
  }
];

export const storage = {
  // Stores
  getStores: () => {
    const stores = localStorage.getItem('stores');
    return stores ? JSON.parse(stores) : initialStores;
  },
  
  saveStores: (stores) => {
    localStorage.setItem('stores', JSON.stringify(stores));
  },
  
  addStore: (store) => {
    const stores = storage.getStores();
    const newStore = {
      ...store,
      id: Date.now(),
      status: 'Active',
      totalProducts: 0,
      totalValue: '$0K',
      totalItems: 0,
      infrastructure: [],
      racks: [],
      freezers: []
    };
    stores.push(newStore);
    storage.saveStores(stores);
    return newStore;
  },
  
  updateStore: (id, updatedData) => {
    const stores = storage.getStores();
    const index = stores.findIndex(store => store.id === id);
    if (index !== -1) {
      stores[index] = { ...stores[index], ...updatedData };
      storage.saveStores(stores);
      return stores[index];
    }
    return null;
  },
  
  deleteStore: (id) => {
    const stores = storage.getStores();
    const filteredStores = stores.filter(store => store.id !== id);
    storage.saveStores(filteredStores);
    return filteredStores;
  },
  
  getStoreById: (id) => {
    const stores = storage.getStores();
    return stores.find(store => store.id === id);
  },
  
  // Invoices Management
  getInvoices: () => {
    const invoices = localStorage.getItem('invoices');
    return invoices ? JSON.parse(invoices) : initialInvoices;
  },
  
  saveInvoices: (invoices) => {
    localStorage.setItem('invoices', JSON.stringify(invoices));
  },
  
  addInvoice: (invoiceData) => {
    const invoices = storage.getInvoices();
    const invoiceCount = invoices.length + 1;
    const invoiceId = `INV-${String(invoiceCount).padStart(3, '0')}`;
    
    const newInvoice = {
      id: invoiceId,
      ...invoiceData,
      status: 'Pending',
      createdAt: new Date().toISOString()
    };
    
    invoices.push(newInvoice);
    storage.saveInvoices(invoices);
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'invoice_created',
      description: `New invoice ${invoiceId} created`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return newInvoice;
  },
  
  updateInvoice: (id, updatedData) => {
    const invoices = storage.getInvoices();
    const index = invoices.findIndex(invoice => invoice.id === id);
    
    if (index !== -1) {
      invoices[index] = { ...invoices[index], ...updatedData };
      storage.saveInvoices(invoices);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'invoice_updated',
        description: `Invoice ${id} updated`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return invoices[index];
    }
    return null;
  },
  
  deleteInvoice: (id) => {
    const invoices = storage.getInvoices();
    const invoiceToDelete = invoices.find(invoice => invoice.id === id);
    const filteredInvoices = invoices.filter(invoice => invoice.id !== id);
    storage.saveInvoices(filteredInvoices);
    
    if (invoiceToDelete) {
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'invoice_deleted',
        description: `Invoice ${id} deleted`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
    }
    
    return filteredInvoices;
  },
  
  getInvoiceById: (id) => {
    const invoices = storage.getInvoices();
    return invoices.find(invoice => invoice.id === id);
  },
  
  approveInvoice: (id) => {
    const invoices = storage.getInvoices();
    const index = invoices.findIndex(invoice => invoice.id === id);
    
    if (index !== -1) {
      invoices[index].status = 'Approved';
      invoices[index].approvedBy = 'Admin';
      invoices[index].approvedDate = new Date().toISOString();
      storage.saveInvoices(invoices);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'invoice_approved',
        description: `Invoice ${id} approved`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return invoices[index];
    }
    return null;
  },
  
  rejectInvoice: (id) => {
    const invoices = storage.getInvoices();
    const index = invoices.findIndex(invoice => invoice.id === id);
    
    if (index !== -1) {
      invoices[index].status = 'Rejected';
      invoices[index].rejectedBy = 'Admin';
      invoices[index].rejectedDate = new Date().toISOString();
      storage.saveInvoices(invoices);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'invoice_rejected',
        description: `Invoice ${id} rejected`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return invoices[index];
    }
    return null;
  },
  
  // Expenditures Management
  getExpenditures: () => {
    const expenditures = localStorage.getItem('expenditures');
    return expenditures ? JSON.parse(expenditures) : initialExpenditures;
  },
  
  saveExpenditures: (expenditures) => {
    localStorage.setItem('expenditures', JSON.stringify(expenditures));
  },
  
  addExpenditure: (expenseData) => {
    const expenditures = storage.getExpenditures();
    const newExpense = {
      id: Date.now(),
      ...expenseData,
      status: 'Pending',
      createdAt: new Date().toISOString()
    };
    
    expenditures.push(newExpense);
    storage.saveExpenditures(expenditures);
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'expense_created',
      description: `New expense added: ${expenseData.description}`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return newExpense;
  },
  
  updateExpenditure: (id, updatedData) => {
    const expenditures = storage.getExpenditures();
    const index = expenditures.findIndex(expense => expense.id === id);
    
    if (index !== -1) {
      expenditures[index] = { ...expenditures[index], ...updatedData };
      storage.saveExpenditures(expenditures);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'expense_updated',
        description: `Expense updated: ${expenditures[index].description}`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return expenditures[index];
    }
    return null;
  },
  
  deleteExpenditure: (id) => {
    const expenditures = storage.getExpenditures();
    const expenseToDelete = expenditures.find(expense => expense.id === id);
    const filteredExpenditures = expenditures.filter(expense => expense.id !== id);
    storage.saveExpenditures(filteredExpenditures);
    
    if (expenseToDelete) {
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'expense_deleted',
        description: `Expense deleted: ${expenseToDelete.description}`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
    }
    
    return filteredExpenditures;
  },
  
  getExpenditureById: (id) => {
    const expenditures = storage.getExpenditures();
    return expenditures.find(expense => expense.id === id);
  },
  
  approveExpenditure: (id) => {
    const expenditures = storage.getExpenditures();
    const index = expenditures.findIndex(expense => expense.id === id);
    
    if (index !== -1) {
      expenditures[index].status = 'Approved';
      expenditures[index].approvedBy = 'Admin';
      expenditures[index].approvedDate = new Date().toISOString();
      storage.saveExpenditures(expenditures);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'expense_approved',
        description: `Expense approved: ${expenditures[index].description}`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return expenditures[index];
    }
    return null;
  },
  
  // Expense Categories Management
  getExpenseCategories: () => {
    const categories = localStorage.getItem('expenseCategories');
    return categories ? JSON.parse(categories) : initialExpenseCategories;
  },
  
  saveExpenseCategories: (categories) => {
    localStorage.setItem('expenseCategories', JSON.stringify(categories));
  },
  
  addExpenseCategory: (categoryName) => {
    const categories = storage.getExpenseCategories();
    if (!categories.includes(categoryName)) {
      categories.push(categoryName);
      storage.saveExpenseCategories(categories);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'expense_category_added',
        description: `New expense category added: ${categoryName}`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return categories;
    }
    return categories;
  },
  
  deleteExpenseCategory: (categoryName) => {
    const categories = storage.getExpenseCategories();
    const filteredCategories = categories.filter(cat => cat !== categoryName);
    storage.saveExpenseCategories(filteredCategories);
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'expense_category_deleted',
      description: `Expense category deleted: ${categoryName}`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return filteredCategories;
  },
  
  // Reports Management
  getReports: () => {
    const reports = localStorage.getItem('reports');
    return reports ? JSON.parse(reports) : initialReports;
  },
  
  saveReports: (reports) => {
    localStorage.setItem('reports', JSON.stringify(reports));
  },
  
  addReport: (reportData) => {
    const reports = storage.getReports();
    const newReport = {
      id: Date.now(),
      ...reportData,
      createdAt: new Date().toISOString()
    };
    
    reports.push(newReport);
    storage.saveReports(reports);
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'report_generated',
      description: `New report generated: ${reportData.name}`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return newReport;
  },
  
  // Stock Distributions Management
  getDistributions: () => {
    const distributions = localStorage.getItem('distributions');
    return distributions ? JSON.parse(distributions) : initialDistributions;
  },
  
  saveDistributions: (distributions) => {
    localStorage.setItem('distributions', JSON.stringify(distributions));
  },
  
  addDistribution: (distributionData) => {
    const distributions = storage.getDistributions();
    const stores = storage.getStores();
    const managers = storage.getManagers();
    const products = storage.getProducts();
    
    const store = stores.find(s => s.id === parseInt(distributionData.storeId));
    const manager = distributionData.managerId 
      ? managers.find(m => m.id === parseInt(distributionData.managerId))
      : null;
    
    // Generate distribution ID
    const distributionCount = distributions.length + 1;
    const distributionId = `DIST-${String(distributionCount).padStart(3, '0')}`;
    
    // Calculate totals
    let totalItems = 0;
    let totalValue = 0;
    
    distributionData.products.forEach(item => {
      totalItems += item.quantity;
      totalValue += item.total;
    });
    
    // Apply discount if credit payment
    let finalTotal = totalValue;
    if (distributionData.paymentType === 'Credit' && distributionData.discount) {
      finalTotal = totalValue * (1 - distributionData.discount / 100);
    }
    
    const newDistribution = {
      id: distributionId,
      storeId: parseInt(distributionData.storeId),
      storeName: store?.name || 'Unknown Store',
      managerId: manager?.id || null,
      managerName: manager?.name || 'Unassigned',
      date: new Date().toISOString().split('T')[0],
      products: distributionData.products,
      totalItems: totalItems,
      totalValue: finalTotal,
      paymentType: distributionData.paymentType,
      status: distributionData.paymentType === 'Paid' ? 'Completed' : 'Pending',
      notes: distributionData.notes || '',
      createdAt: new Date().toISOString(),
      discount: distributionData.discount || 0
    };
    
    // Update product stock
    distributionData.products.forEach(item => {
      const product = products.find(p => p.id === item.productId);
      if (product) {
        const updatedStock = product.stock - item.quantity;
        storage.updateProduct(product.id, { stock: updatedStock });
      }
    });
    
    distributions.push(newDistribution);
    storage.saveDistributions(distributions);
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'distribution_created',
      description: `New distribution ${distributionId} to ${store?.name}`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return newDistribution;
  },
  
  updateDistribution: (id, updatedData) => {
    const distributions = storage.getDistributions();
    const index = distributions.findIndex(dist => dist.id === id);
    
    if (index !== -1) {
      distributions[index] = { ...distributions[index], ...updatedData };
      storage.saveDistributions(distributions);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'distribution_updated',
        description: `Distribution ${id} updated`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return distributions[index];
    }
    return null;
  },
  
  deleteDistribution: (id) => {
    const distributions = storage.getDistributions();
    const distributionToDelete = distributions.find(dist => dist.id === id);
    const filteredDistributions = distributions.filter(dist => dist.id !== id);
    storage.saveDistributions(filteredDistributions);
    
    if (distributionToDelete) {
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'distribution_deleted',
        description: `Distribution ${id} deleted`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
    }
    
    return filteredDistributions;
  },
  
  getDistributionById: (id) => {
    const distributions = storage.getDistributions();
    return distributions.find(dist => dist.id === id);
  },
  
  updateDistributionStatus: (id, status) => {
    const distributions = storage.getDistributions();
    const index = distributions.findIndex(dist => dist.id === id);
    
    if (index !== -1) {
      distributions[index].status = status;
      storage.saveDistributions(distributions);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'distribution_status_changed',
        description: `Distribution ${id} status changed to ${status}`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return distributions[index];
    }
    return null;
  },
  
  // Infrastructure Management
  addRoom: (storeId, roomData) => {
    const stores = storage.getStores();
    const storeIndex = stores.findIndex(store => store.id === storeId);
    
    if (storeIndex !== -1) {
      const newRoom = {
        id: Date.now(),
        ...roomData,
        type: 'room'
      };
      
      if (!stores[storeIndex].infrastructure) {
        stores[storeIndex].infrastructure = [];
      }
      
      stores[storeIndex].infrastructure.push(newRoom);
      
      stores[storeIndex].totalItems = (stores[storeIndex].totalItems || 0) + roomData.items;
      
      storage.saveStores(stores);
      return newRoom;
    }
    return null;
  },
  
  addRack: (storeId, rackData) => {
    const stores = storage.getStores();
    const storeIndex = stores.findIndex(store => store.id === storeId);
    
    if (storeIndex !== -1) {
      const newRack = {
        id: Date.now(),
        ...rackData,
        type: 'rack'
      };
      
      if (!stores[storeIndex].racks) {
        stores[storeIndex].racks = [];
      }
      
      stores[storeIndex].racks.push(newRack);
      
      const currentItems = parseInt(rackData.items?.split('/')[0]?.trim() || '0');
      stores[storeIndex].totalItems = (stores[storeIndex].totalItems || 0) + currentItems;
      
      storage.saveStores(stores);
      return newRack;
    }
    return null;
  },
  
  addFreezer: (storeId, freezerData) => {
    const stores = storage.getStores();
    const storeIndex = stores.findIndex(store => store.id === storeId);
    
    if (storeIndex !== -1) {
      const newFreezer = {
        id: Date.now(),
        ...freezerData,
        type: 'freezer'
      };
      
      if (!stores[storeIndex].freezers) {
        stores[storeIndex].freezers = [];
      }
      
      stores[storeIndex].freezers.push(newFreezer);
      storage.saveStores(stores);
      return newFreezer;
    }
    return null;
  },
  
  deleteRoom: (storeId, roomId) => {
    const stores = storage.getStores();
    const storeIndex = stores.findIndex(store => store.id === storeId);
    
    if (storeIndex !== -1 && stores[storeIndex].infrastructure) {
      const roomIndex = stores[storeIndex].infrastructure.findIndex(room => room.id === roomId);
      if (roomIndex !== -1) {
        stores[storeIndex].totalItems = Math.max(0, (stores[storeIndex].totalItems || 0) - (stores[storeIndex].infrastructure[roomIndex].items || 0));
        
        stores[storeIndex].infrastructure.splice(roomIndex, 1);
        storage.saveStores(stores);
        return true;
      }
    }
    return false;
  },
  
  deleteRack: (storeId, rackId) => {
    const stores = storage.getStores();
    const storeIndex = stores.findIndex(store => store.id === storeId);
    
    if (storeIndex !== -1 && stores[storeIndex].racks) {
      const rackIndex = stores[storeIndex].racks.findIndex(rack => rack.id === rackId);
      if (rackIndex !== -1) {
        const currentItems = parseInt(stores[storeIndex].racks[rackIndex].items?.split('/')[0]?.trim() || '0');
        stores[storeIndex].totalItems = Math.max(0, (stores[storeIndex].totalItems || 0) - currentItems);
        
        stores[storeIndex].racks.splice(rackIndex, 1);
        storage.saveStores(stores);
        return true;
      }
    }
    return false;
  },
  
  deleteFreezer: (storeId, freezerId) => {
    const stores = storage.getStores();
    const storeIndex = stores.findIndex(store => store.id === storeId);
    
    if (storeIndex !== -1 && stores[storeIndex].freezers) {
      const freezerIndex = stores[storeIndex].freezers.findIndex(freezer => freezer.id === freezerId);
      if (freezerIndex !== -1) {
        stores[storeIndex].freezers.splice(freezerIndex, 1);
        storage.saveStores(stores);
        return true;
      }
    }
    return false;
  },
  
  // Enhanced Outlets Management
  getOutlets: () => {
    const outlets = localStorage.getItem('outlets');
    return outlets ? JSON.parse(outlets) : initialOutlets;
  },
  
  saveOutlets: (outlets) => {
    localStorage.setItem('outlets', JSON.stringify(outlets));
  },
  
  addOutlet: (outlet) => {
    const outlets = storage.getOutlets();
    const newOutlet = {
      ...outlet,
      id: Date.now(),
      status: 'Active',
      creditUsed: 0,
      totalOrders: 0,
      lastOrder: 'No orders yet',
      orderHistory: [],
      creditHistory: [],
      createdAt: new Date().toISOString()
    };
    outlets.push(newOutlet);
    storage.saveOutlets(outlets);
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'outlet_created',
      description: `New outlet "${outlet.name}" created`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return newOutlet;
  },
  
  updateOutlet: (id, updatedData) => {
    const outlets = storage.getOutlets();
    const index = outlets.findIndex(outlet => outlet.id === id);
    if (index !== -1) {
      outlets[index] = { ...outlets[index], ...updatedData };
      storage.saveOutlets(outlets);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'outlet_updated',
        description: `Outlet "${outlets[index].name}" updated`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return outlets[index];
    }
    return null;
  },
  
  deleteOutlet: (id) => {
    const outlets = storage.getOutlets();
    const outletToDelete = outlets.find(outlet => outlet.id === id);
    const filteredOutlets = outlets.filter(outlet => outlet.id !== id);
    storage.saveOutlets(filteredOutlets);
    
    if (outletToDelete) {
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'outlet_deleted',
        description: `Outlet "${outletToDelete.name}" deleted`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
    }
    
    return filteredOutlets;
  },
  
  getOutletById: (id) => {
    const outlets = storage.getOutlets();
    return outlets.find(outlet => outlet.id === id);
  },
  
  addOutletOrder: (outletId, orderData) => {
    const outlets = storage.getOutlets();
    const index = outlets.findIndex(outlet => outlet.id === outletId);
    
    if (index !== -1) {
      const orderId = `INV-${String(outlets[index].totalOrders + 1).padStart(3, '0')}`;
      const newOrder = {
        id: orderId,
        ...orderData,
        date: new Date().toISOString().split('T')[0]
      };
      
      outlets[index].totalOrders += 1;
      outlets[index].lastOrder = new Date().toISOString().split('T')[0];
      outlets[index].creditUsed += orderData.amount;
      
      if (!outlets[index].orderHistory) {
        outlets[index].orderHistory = [];
      }
      outlets[index].orderHistory.unshift(newOrder);
      
      if (!outlets[index].creditHistory) {
        outlets[index].creditHistory = [];
      }
      outlets[index].creditHistory.unshift({
        date: new Date().toISOString().split('T')[0],
        type: 'Purchase',
        amount: orderData.amount,
        balance: outlets[index].creditLimit - (outlets[index].creditUsed + orderData.amount)
      });
      
      storage.saveOutlets(outlets);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'order_created',
        description: `New order ${orderId} for ${outlets[index].name}`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return newOrder;
    }
    return null;
  },
  
  addPayment: (outletId, paymentData) => {
    const outlets = storage.getOutlets();
    const index = outlets.findIndex(outlet => outlet.id === outletId);
    
    if (index !== -1) {
      outlets[index].creditUsed = Math.max(0, outlets[index].creditUsed - paymentData.amount);
      
      if (!outlets[index].creditHistory) {
        outlets[index].creditHistory = [];
      }
      outlets[index].creditHistory.unshift({
        date: new Date().toISOString().split('T')[0],
        type: 'Payment',
        amount: paymentData.amount,
        balance: outlets[index].creditLimit - outlets[index].creditUsed
      });
      
      storage.saveOutlets(outlets);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'payment_received',
        description: `Payment of $${paymentData.amount} from ${outlets[index].name}`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return outlets[index];
    }
    return null;
  },
  
  // Managers Management
  getManagers: () => {
    const managers = localStorage.getItem('managers');
    return managers ? JSON.parse(managers) : initialManagers;
  },
  
  saveManagers: (managers) => {
    localStorage.setItem('managers', JSON.stringify(managers));
  },
  
  addManager: (managerData) => {
    const managers = storage.getManagers();
    const stores = storage.getStores();
    const selectedStore = stores.find(store => store.id === parseInt(managerData.storeId));
    
    const newManager = {
      id: Date.now(),
      ...managerData,
      storeName: selectedStore ? selectedStore.name : 'Unassigned',
      status: 'Active',
      lastLogin: 'Never',
      invoices: 0,
      createdAt: new Date().toISOString()
    };
    
    managers.push(newManager);
    storage.saveManagers(managers);
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'manager_created',
      description: `New manager "${managerData.name}" created`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return newManager;
  },
  
  updateManager: (id, updatedData) => {
    const managers = storage.getManagers();
    const stores = storage.getStores();
    const index = managers.findIndex(manager => manager.id === id);
    
    if (index !== -1) {
      const selectedStore = stores.find(store => store.id === parseInt(updatedData.storeId));
      
      managers[index] = { 
        ...managers[index], 
        ...updatedData,
        storeName: selectedStore ? selectedStore.name : managers[index].storeName
      };
      storage.saveManagers(managers);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'manager_updated',
        description: `Manager "${managers[index].name}" updated`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return managers[index];
    }
    return null;
  },
  
  deleteManager: (id) => {
    const managers = storage.getManagers();
    const managerToDelete = managers.find(manager => manager.id === id);
    const filteredManagers = managers.filter(manager => manager.id !== id);
    storage.saveManagers(filteredManagers);
    
    if (managerToDelete) {
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'manager_deleted',
        description: `Manager "${managerToDelete.name}" deleted`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
    }
    
    return filteredManagers;
  },
  
  getManagerById: (id) => {
    const managers = storage.getManagers();
    return managers.find(manager => manager.id === id);
  },
  
  resendCredentials: (managerId) => {
    const managers = storage.getManagers();
    const index = managers.findIndex(manager => manager.id === managerId);
    
    if (index !== -1) {
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'credentials_resent',
        description: `Credentials resent to "${managers[index].name}"`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return true;
    }
    return false;
  },
  
  // Products Management
  getProducts: () => {
    const products = localStorage.getItem('products');
    return products ? JSON.parse(products) : initialProducts;
  },
  
  saveProducts: (products) => {
    localStorage.setItem('products', JSON.stringify(products));
  },
  
  addProduct: (productData) => {
    const products = storage.getProducts();
    const newProduct = {
      id: Date.now(),
      ...productData,
      status: productData.stock > 0 ? 'In Stock' : 'Out of Stock',
      createdAt: new Date().toISOString()
    };
    
    if (productData.stock < productData.minStock) {
      newProduct.status = 'Low Stock';
    }
    
    products.push(newProduct);
    storage.saveProducts(products);
    
    if (newProduct.stock < newProduct.minStock) {
      storage.addStockAlert({
        productId: newProduct.id,
        productName: newProduct.name,
        sku: newProduct.sku,
        currentStock: newProduct.stock,
        minStock: newProduct.minStock,
        category: newProduct.category
      });
    }
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'product_created',
      description: `New product "${productData.name}" added`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return newProduct;
  },
  
  updateProduct: (id, updatedData) => {
    const products = storage.getProducts();
    const index = products.findIndex(product => product.id === id);
    
    if (index !== -1) {
      let status = 'In Stock';
      if (updatedData.stock === 0) {
        status = 'Out of Stock';
      } else if (updatedData.stock < (updatedData.minStock || products[index].minStock)) {
        status = 'Low Stock';
      }
      
      products[index] = { 
        ...products[index], 
        ...updatedData,
        status: status
      };
      
      storage.saveProducts(products);
      
      if (products[index].stock < products[index].minStock) {
        storage.addStockAlert({
          productId: products[index].id,
          productName: products[index].name,
          sku: products[index].sku,
          currentStock: products[index].stock,
          minStock: products[index].minStock,
          category: products[index].category
        });
      } else {
        const alerts = storage.getStockAlerts();
        const filteredAlerts = alerts.filter(alert => alert.productId !== id);
        storage.saveStockAlerts(filteredAlerts);
      }
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'product_updated',
        description: `Product "${products[index].name}" updated`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return products[index];
    }
    return null;
  },
  
  deleteProduct: (id) => {
    const products = storage.getProducts();
    const productToDelete = products.find(product => product.id === id);
    const filteredProducts = products.filter(product => product.id !== id);
    storage.saveProducts(filteredProducts);
    
    const alerts = storage.getStockAlerts();
    const filteredAlerts = alerts.filter(alert => alert.productId !== id);
    storage.saveStockAlerts(filteredAlerts);
    
    if (productToDelete) {
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'product_deleted',
        description: `Product "${productToDelete.name}" deleted`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
    }
    
    return filteredProducts;
  },
  
  getProductById: (id) => {
    const products = storage.getProducts();
    return products.find(product => product.id === id);
  },
  
  // Categories Management
  getCategories: () => {
    const categories = localStorage.getItem('categories');
    return categories ? JSON.parse(categories) : initialCategories;
  },
  
  saveCategories: (categories) => {
    localStorage.setItem('categories', JSON.stringify(categories));
  },
  
  addCategory: (categoryName) => {
    const categories = storage.getCategories();
    if (!categories.includes(categoryName)) {
      categories.push(categoryName);
      storage.saveCategories(categories);
      
      const activities = storage.getRecentActivities();
      activities.unshift({
        id: Date.now(),
        type: 'category_added',
        description: `New category "${categoryName}" added`,
        timestamp: new Date().toISOString(),
        user: 'Admin'
      });
      storage.saveRecentActivities(activities);
      
      return categories;
    }
    return categories;
  },
  
  deleteCategory: (categoryName) => {
    const categories = storage.getCategories();
    const filteredCategories = categories.filter(cat => cat !== categoryName);
    storage.saveCategories(filteredCategories);
    
    const activities = storage.getRecentActivities();
    activities.unshift({
      id: Date.now(),
      type: 'category_deleted',
      description: `Category "${categoryName}" deleted`,
      timestamp: new Date().toISOString(),
      user: 'Admin'
    });
    storage.saveRecentActivities(activities);
    
    return filteredCategories;
  },
  
  // Stock Alerts
  addStockAlert: (alertData) => {
    const alerts = storage.getStockAlerts();
    const existingAlertIndex = alerts.findIndex(alert => alert.productId === alertData.productId);
    
    if (existingAlertIndex !== -1) {
      alerts[existingAlertIndex] = {
        ...alerts[existingAlertIndex],
        ...alertData,
        timestamp: new Date().toISOString()
      };
    } else {
      alerts.unshift({
        id: Date.now(),
        ...alertData,
        timestamp: new Date().toISOString(),
        status: 'Pending'
      });
    }
    
    storage.saveStockAlerts(alerts);
  },
  
  // Other functions
  getPendingApprovals: () => {
    const approvals = localStorage.getItem('pendingApprovals');
    return approvals ? JSON.parse(approvals) : pendingApprovals;
  },
  
  savePendingApprovals: (approvals) => {
    localStorage.setItem('pendingApprovals', JSON.stringify(approvals));
  },
  
  getCreditDues: () => {
    const dues = localStorage.getItem('creditDues');
    return dues ? JSON.parse(dues) : creditDues;
  },
  
  saveCreditDues: (dues) => {
    localStorage.setItem('creditDues', JSON.stringify(dues));
  },
  
  getStockAlerts: () => {
    const alerts = localStorage.getItem('stockAlerts');
    return alerts ? JSON.parse(alerts) : stockAlerts;
  },
  
  saveStockAlerts: (alerts) => {
    localStorage.setItem('stockAlerts', JSON.stringify(alerts));
  },
  
  getRecentActivities: () => {
    const activities = localStorage.getItem('recentActivities');
    return activities ? JSON.parse(activities) : recentActivities;
  },
  
  saveRecentActivities: (activities) => {
    localStorage.setItem('recentActivities', JSON.stringify(activities));
  },
  
  initializeData: () => {
    if (!localStorage.getItem('stores')) {
      localStorage.setItem('stores', JSON.stringify(initialStores));
    }
    if (!localStorage.getItem('outlets')) {
      localStorage.setItem('outlets', JSON.stringify(initialOutlets));
    }
    if (!localStorage.getItem('managers')) {
      localStorage.setItem('managers', JSON.stringify(initialManagers));
    }
    if (!localStorage.getItem('products')) {
      localStorage.setItem('products', JSON.stringify(initialProducts));
    }
    if (!localStorage.getItem('categories')) {
      localStorage.setItem('categories', JSON.stringify(initialCategories));
    }
    if (!localStorage.getItem('distributions')) {
      localStorage.setItem('distributions', JSON.stringify(initialDistributions));
    }
    if (!localStorage.getItem('invoices')) {
      localStorage.setItem('invoices', JSON.stringify(initialInvoices));
    }
    if (!localStorage.getItem('expenditures')) {
      localStorage.setItem('expenditures', JSON.stringify(initialExpenditures));
    }
    if (!localStorage.getItem('expenseCategories')) {
      localStorage.setItem('expenseCategories', JSON.stringify(initialExpenseCategories));
    }
    if (!localStorage.getItem('reports')) {
      localStorage.setItem('reports', JSON.stringify(initialReports));
    }
    if (!localStorage.getItem('pendingApprovals')) {
      localStorage.setItem('pendingApprovals', JSON.stringify(pendingApprovals));
    }
    if (!localStorage.getItem('creditDues')) {
      localStorage.setItem('creditDues', JSON.stringify(creditDues));
    }
    if (!localStorage.getItem('stockAlerts')) {
      localStorage.setItem('stockAlerts', JSON.stringify(stockAlerts));
    }
    if (!localStorage.getItem('recentActivities')) {
      localStorage.setItem('recentActivities', JSON.stringify(recentActivities));
    }
  }
};